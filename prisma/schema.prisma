// schema.prisma
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextIndex"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model ApiBill {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  
  // Service info
  service     String?
  apiName     String?
  
  // Billing period
  month       Int?
  year        Int?
  period      String?
  
  // Cost
  amount      Float?
  currency    String?   @default("USD")
  
  // Usage metrics (store as embedded object)
  usage       Json?
  
  // Status
  status      String?   @default("pending")
  paidAt      DateTime?
  dueDate     DateTime?
  
  // Provider invoice info
  invoiceId   String?
  invoiceUrl  String?
  
  // Tags for filtering
  tags        String[]
  
  // Timestamps
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt
  
  @@index([service, year, month])
  @@index([status])
  @@index([dueDate])
}

model Visitor {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId String?
  ip        String?
  page      String?
  referer   String?  @default("direct")
  userAgent String?
  country   String?  @default("Unknown")
  city      String?  @default("Unknown")
  timestamp DateTime? @default(now())
  
  @@index([timestamp])
  @@index([sessionId])
  @@index([ip])
  @@index([page])
  @@map("visitors")
}

// User Management
model User {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  email           String           @unique
  password        String?
  firstName       String?
  lastName        String?
  avatar          String?
  phone           String?
  emailVerified   Boolean?         @default(false)
  createdAt       DateTime?        @default(now())
  updatedAt       DateTime?        @updatedAt
  role            Role?            @default(USER)

  // Relationships
  addresses       Address[]
  products        Product[]
  orders          Order[]
  reviews         Review[]
  wishlist        WishlistItem[]
  cart            CartItem[]
  payments        Payment[]
  messagesSent    Message[]        @relation("MessageSender")
  messagesReceived Message[]       @relation("MessageRecipient")
  supportTickets  SupportTicket[]
  notifications   Notification[]
  ticketResponses TicketResponse[]
  
  // Social features (NEW) - Using explicit relations for MongoDB
  posts           Post[]
  comments        Comment[]
  likes           Like[]
  followers       Follow[]         @relation("Follower")
  following       Follow[]         @relation("Following")
  taggedPosts     PostTaggedUser[]
  blacklistedTokens  BlacklistedToken[]
  
  // Indexes
  @@index([createdAt])
  @@map("users")
}

model BlacklistedToken {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  token     String   @unique
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime? @default(now())
  expiresAt DateTime?
  @@index([userId])
  @@index([expiresAt])
}

// Social Media Models (NEW)
model Post {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  userId          String?         @db.ObjectId
  content         String?
  background      String?
  images          String[]
  createdAt       DateTime?       @default(now())
  updatedAt       DateTime?       @updatedAt
  privacy         PrivacySetting? @default(PUBLIC)

  // Relationships
  user            User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments        Comment[]
  likes           Like[]
  taggedUsers     PostTaggedUser[]

  // Indexes
  @@index([userId])
  @@index([createdAt])
  @@fulltext([content])
  @@map("posts")
}

// Explicit many-to-many for tagged users (required for MongoDB)
model PostTaggedUser {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  postId    String?  @db.ObjectId
  userId    String?  @db.ObjectId
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([postId, userId])
  @@map("post_tagged_users")
}

model Comment {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  postId          String?         @db.ObjectId
  userId          String?         @db.ObjectId
  content         String?
  parentId        String?         @db.ObjectId
  createdAt       DateTime?       @default(now())
  updatedAt       DateTime?       @updatedAt

  // Relationships
  post            Post?           @relation(fields: [postId], references: [id], onDelete: Cascade)
  user            User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent          Comment?        @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies         Comment[]       @relation("CommentReplies")
  likes           Like[]

  // Indexes
  @@index([postId])
  @@index([userId])
  @@index([parentId])
  @@map("comments")
}

model Like {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  postId          String?         @db.ObjectId
  commentId       String?         @db.ObjectId
  userId          String?         @db.ObjectId
  createdAt       DateTime?       @default(now())

  // Relationships
  post            Post?           @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment         Comment?        @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user            User?           @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ensure a like is for either a post or comment, not both
  @@unique([userId, postId, commentId])
  @@index([userId])
  @@index([postId])
  @@index([commentId])
  @@map("likes")
}

model Follow {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  followerId      String?         @db.ObjectId
  followingId     String?         @db.ObjectId
  createdAt       DateTime?       @default(now())

  // Relationships
  follower        User?           @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following       User?           @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  // Ensure unique follow relationships
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// Address Management
model Address {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String?  @db.ObjectId
  type        AddressType?
  receiver    String?
  street      String?
  city        String?
  state       String?
  zipCode     String?
  country     String?
  isDefault   Boolean? @default(false)
  createdAt   DateTime? @default(now())

  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders      Order[]

  @@index([userId])
  @@map("addresses")
}

// Product Catalog
model Product {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String?
  description String?
  price       Float?
  salePrice   Float?
  sku         String   @unique
  stock       Int?     @default(0)
  images      String[]
  categoryId  String?  @db.ObjectId
  brand       String?
  weight      Float?
  dimensions  String?
  isActive    Boolean? @default(true)
  featured    Boolean? @default(false)
  tags        String[]
  attributes  Json?
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt
  supplierId  String? @default("68c8c1765038c47a4b9ef519") @db.ObjectId
  model       String? @default("https://portfolio-xi-eight-92.vercel.app/watch_test.glb")
  category    Category? @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  supplier    User?    @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  variants    ProductVariant[]
  orders      OrderItem[]
  reviews     Review[]
  wishlist    WishlistItem[]
  cart        CartItem[]

  @@index([categoryId])
  @@index([price])
  @@index([brand])
  @@index([isActive])
  @@index([featured])
  @@index([createdAt])
  @@fulltext([name, description, tags])
  @@map("products")
}

model ProductVariant {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  productId   String?  @db.ObjectId
  name        String?
  sku         String   @unique
  color       String?
  size        String?
  price       Float?
  salePrice   Float?
  stock       Int?     @default(0)
  weight      Float?
  images      String[]
  model       String? @default("https://portfolio-xi-eight-92.vercel.app/watch_test.glb")
  isActive    Boolean? @default(true)
  options     String[]
  createdAt   DateTime? @default(now())

  product     Product? @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([color])
  @@index([size])
  @@index([isActive])
  @@map("product_variants")
}

model Category {
  id        String     @id @default(auto()) @map("_id") @db.ObjectId
  name      String?
  description String?
  image     String?
  parentId  String?    @db.ObjectId
  isActive  Boolean?   @default(true)
  createdAt DateTime?  @default(now())

  parent    Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children  Category[] @relation("CategoryHierarchy")
  products  Product[]

  @@index([parentId])
  @@map("categories")
}

// Order Management
model Order {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String?  @db.ObjectId
  riderId     String?
  orderNumber String   @unique
  status      OrderStatus?
  total       Float?
  subtotal    Float?
  tax         Float?   @default(0)
  shipping    Float?   @default(0)
  discount    Float?   @default(0)
  addressId   String?  @db.ObjectId
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt

  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  address     Address? @relation(fields: [addressId], references: [id])
  items       OrderItem[]
  payments    Payment[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

model OrderItem {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  orderId     String?  @db.ObjectId
  productId   String?  @db.ObjectId
  supplierId  String?
  quantity    Int?
  price       Float?
  variantInfo String?
  status      OrderStatus?
  order       Order?  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product     Product? @relation(fields: [productId], references: [id])
  riderId     String?
  recipientName        String?
  recipientPhone       String?
  pickupAddress        String?
  pickupLatitude       Float?
  pickupLongitude      Float?
  dropoffAddress       String?
  dropoffLatitude      Float?
  dropoffLongitude     Float?
  estimatedDeliveryTime DateTime?
  eta                  String?
  actualDeliveryTime   DateTime?
  ata                  String?
  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

// Cart
model CartItem {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String?  @db.ObjectId
  productId   String?  @db.ObjectId
  quantity    Int?     @default(1)
  variantInfo String?
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt

  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product     Product? @relation(fields: [productId], references: [id])

  @@index([userId])
  @@map("cart_items")
}

// Wishlist
model WishlistItem {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?  @db.ObjectId
  productId String?  @db.ObjectId
  createdAt DateTime? @default(now())

  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product? @relation(fields: [productId], references: [id])

  @@index([userId])
  @@index([productId])
  @@map("wishlist_items")
}

// Payments
model Payment {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  orderId       String?       @db.ObjectId
  userId        String?       @db.ObjectId
  amount        Float?
  method        PaymentMethod?
  status        PaymentStatus?
  transactionId String?
  details       String?
  createdAt     DateTime?     @default(now())

  order         Order? @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user          User?  @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
  @@index([status])
  @@map("payments")
}

// Reviews
model Review {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?  @db.ObjectId
  productId String?  @db.ObjectId
  rating    Int?
  title     String?
  comment   String?
  isApproved Boolean? @default(false)
  createdAt DateTime? @default(now())

  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product? @relation(fields: [productId], references: [id])

  @@index([userId])
  @@index([productId])
  @@index([rating])
  @@index([isApproved])
  @@map("reviews")
}

// Messaging
model Message {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  senderId    String?  @db.ObjectId
  recipientId String?  @db.ObjectId
  subject     String?
  body        String?
  isRead      Boolean? @default(false)
  parentId    String?  @db.ObjectId
  createdAt   DateTime? @default(now())

  sender      User?    @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  recipient   User?    @relation("MessageRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  parent      Message? @relation("MessageThread", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies     Message[] @relation("MessageThread")

  @@index([senderId])
  @@index([recipientId])
  @@index([parentId])
  @@index([isRead])
  @@index([createdAt])
  @@map("messages")
}

// Support
model SupportTicket {
  id          String         @id @default(auto()) @map("_id") @db.ObjectId
  userId      String?        @db.ObjectId
  subject     String?
  description String?
  status      TicketStatus?  @default(OPEN)
  priority    TicketPriority? @default(MEDIUM)
  assignedTo  String?        @db.ObjectId
  createdAt   DateTime?      @default(now())
  updatedAt   DateTime?      @updatedAt

  user        User?          @relation(fields: [userId], references: [id], onDelete: Cascade)
  responses   TicketResponse[]

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([assignedTo])
  @@index([createdAt])
  @@map("support_tickets")
}

model TicketResponse {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  ticketId  String?       @db.ObjectId
  userId    String?       @db.ObjectId
  message   String?
  isInternal Boolean?     @default(false)
  createdAt DateTime?     @default(now())

  ticket    SupportTicket? @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User?          @relation(fields: [userId], references: [id])

  @@index([ticketId])
  @@index([userId])
  @@index([isInternal])
  @@map("ticket_responses")
}

// Notifications
model Notification {
  id        String           @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?          @db.ObjectId
  type      NotificationType?
  title     String?
  message   String?
  isRead    Boolean?         @default(false)
  link      String?
  createdAt DateTime?        @default(now())

  user      User?            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

model TrackingCounter {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  date      DateTime? @unique
  counter   Int?
}

// Enums remain the same
enum Role {
  ADMIN
  MANAGER
  USER
}

enum AddressType {
  HOME
  WORK
  BILLING
  SHIPPING
}

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  CREDIT_CARD
  PAYPAL
  STRIPE
  BANK_TRANSFER
  COD
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum NotificationType {
  ORDER_UPDATE
  PAYMENT_CONFIRMATION
  SHIPMENT
  PROMOTIONAL
  SUPPORT
  SOCIAL
}

// NEW Enums for Social Features
enum PrivacySetting {
  PUBLIC
  FRIENDS
  ONLY_ME
}
